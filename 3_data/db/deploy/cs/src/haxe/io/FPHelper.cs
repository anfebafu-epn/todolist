// Generated by Haxe 4.2.2

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.io {
	public class FPHelper : global::haxe.lang.HxObject {
		
		public FPHelper(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public FPHelper() {
			global::haxe.io.FPHelper.__hx_ctor_haxe_io_FPHelper(this);
		}
		
		
		protected static void __hx_ctor_haxe_io_FPHelper(global::haxe.io.FPHelper __hx_this) {
		}
		
		
		public static double i32ToFloat(int i) {
			unchecked {
				global::haxe.io._FPHelper.SingleHelper helper = new global::haxe.io._FPHelper.SingleHelper(((float) (0) ));
				if (global::System.BitConverter.IsLittleEndian) {
					helper.i = i;
				}
				else {
					helper.i = ( ( ( ( ((int) (( ((uint) (i) ) >> 24 )) ) & 255 ) | ( (( ( i >> 16 ) & 255 )) << 8 ) ) | ( (( ( i >> 8 ) & 255 )) << 16 ) ) | ( (( i & 255 )) << 24 ) );
				}
				
				return ((double) (helper.f) );
			}
		}
		
		
		public static int floatToI32(double f) {
			unchecked {
				global::haxe.io._FPHelper.SingleHelper helper = new global::haxe.io._FPHelper.SingleHelper(((float) (f) ));
				if (global::System.BitConverter.IsLittleEndian) {
					return helper.i;
				}
				else {
					int i = helper.i;
					return ( ( ( ( ((int) (( ((uint) (i) ) >> 24 )) ) & 255 ) | ( (( ( i >> 16 ) & 255 )) << 8 ) ) | ( (( ( i >> 8 ) & 255 )) << 16 ) ) | ( (( i & 255 )) << 24 ) );
				}
				
			}
		}
		
		
		public static double i64ToDouble(int low, int high) {
			unchecked {
				global::haxe.io._FPHelper.FloatHelper helper = new global::haxe.io._FPHelper.FloatHelper(((double) (0) ));
				if (global::System.BitConverter.IsLittleEndian) {
					long this1 = ( ( ((long) (high) ) << 32 ) | ( ((long) (low) ) & 0xffffffffL ) );
					helper.i = ((long) (this1) );
				}
				else {
					int i1 = high;
					int i2 = low;
					int j2 = ( ( ( ( ((int) (( ((uint) (i1) ) >> 24 )) ) & 255 ) | ( (( ( i1 >> 16 ) & 255 )) << 8 ) ) | ( (( ( i1 >> 8 ) & 255 )) << 16 ) ) | ( (( i1 & 255 )) << 24 ) );
					int j1 = ( ( ( ( ((int) (( ((uint) (i2) ) >> 24 )) ) & 255 ) | ( (( ( i2 >> 16 ) & 255 )) << 8 ) ) | ( (( ( i2 >> 8 ) & 255 )) << 16 ) ) | ( (( i2 & 255 )) << 24 ) );
					long this2 = ( ( ((long) (j1) ) << 32 ) | ( ((long) (j2) ) & 0xffffffffL ) );
					helper.i = ((long) (this2) );
				}
				
				return helper.f;
			}
		}
		
		
		public static long doubleToI64(double v) {
			unchecked {
				global::haxe.io._FPHelper.FloatHelper helper = new global::haxe.io._FPHelper.FloatHelper(v);
				if (global::System.BitConverter.IsLittleEndian) {
					return helper.i;
				}
				else {
					long i = helper.i;
					int i1 = ((int) (( ((long) (i) ) >> 32 )) );
					int i2 = ((int) (((long) (i) )) );
					int j2 = ( ( ( ( ((int) (( ((uint) (i1) ) >> 24 )) ) & 255 ) | ( (( ( i1 >> 16 ) & 255 )) << 8 ) ) | ( (( ( i1 >> 8 ) & 255 )) << 16 ) ) | ( (( i1 & 255 )) << 24 ) );
					int j1 = ( ( ( ( ((int) (( ((uint) (i2) ) >> 24 )) ) & 255 ) | ( (( ( i2 >> 16 ) & 255 )) << 8 ) ) | ( (( ( i2 >> 8 ) & 255 )) << 16 ) ) | ( (( i2 & 255 )) << 24 ) );
					long this1 = ( ( ((long) (j1) ) << 32 ) | ( ((long) (j2) ) & 0xffffffffL ) );
					return ((long) (this1) );
				}
				
			}
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.io._FPHelper {
	[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
	public struct SingleHelper {
		
		public SingleHelper(float f) {
			this.i = 0;
			this.f = f;
		}
		
		
		[System.Runtime.InteropServices.FieldOffset(0)]
		public int i;
		
		[System.Runtime.InteropServices.FieldOffset(0)]
		public float f;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.io._FPHelper {
	[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
	public struct FloatHelper {
		
		public FloatHelper(double f) {
			this.i = ((long) (0) );
			this.f = f;
		}
		
		
		[System.Runtime.InteropServices.FieldOffset(0)]
		public long i;
		
		[System.Runtime.InteropServices.FieldOffset(0)]
		public double f;
		
	}
}


