// Generated by Haxe 4.2.2

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys.thread {
	public class NextEventTime : global::haxe.lang.Enum {
		
		protected NextEventTime(int index) : base(index) {
		}
		
		
		public static readonly global::sys.thread.NextEventTime Now = new global::sys.thread.NextEventTime_Now();
		
		public static readonly global::sys.thread.NextEventTime Never = new global::sys.thread.NextEventTime_Never();
		
		public static global::sys.thread.NextEventTime AnyTime(global::haxe.lang.Null<double> time) {
			return new global::sys.thread.NextEventTime_AnyTime(time);
		}
		
		
		public static global::sys.thread.NextEventTime At(double time) {
			return new global::sys.thread.NextEventTime_At(time);
		}
		
		
		protected static readonly string[] __hx_constructs = new string[]{"Now", "Never", "AnyTime", "At"};
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys.thread {
	public sealed class NextEventTime_Now : global::sys.thread.NextEventTime {
		
		public NextEventTime_Now() : base(0) {
		}
		
		
		public override string getTag() {
			return "Now";
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys.thread {
	public sealed class NextEventTime_Never : global::sys.thread.NextEventTime {
		
		public NextEventTime_Never() : base(1) {
		}
		
		
		public override string getTag() {
			return "Never";
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys.thread {
	public sealed class NextEventTime_AnyTime : global::sys.thread.NextEventTime {
		
		public NextEventTime_AnyTime(global::haxe.lang.Null<double> time) : base(2) {
			this.time = time;
		}
		
		
		public override global::Array<object> getParams() {
			return new global::Array<object>(new object[]{(this.time).toDynamic()});
		}
		
		
		public override string getTag() {
			return "AnyTime";
		}
		
		
		public override int GetHashCode() {
			unchecked {
				return global::haxe.lang.Enum.paramsGetHashCode(2, new object[]{(this.time).toDynamic()});
			}
		}
		
		
		public override bool Equals(object other) {
			if (global::System.Object.ReferenceEquals(((object) (this) ), ((object) (other) ))) {
				return true;
			}
			
			global::sys.thread.NextEventTime_AnyTime en = ( other as global::sys.thread.NextEventTime_AnyTime );
			if (( en == null )) {
				return false;
			}
			
			if ( ! (global::Type.enumEq<object>((this.time).toDynamic(), (en.time).toDynamic())) ) {
				return false;
			}
			
			return true;
		}
		
		
		public override string toString() {
			return global::haxe.lang.Enum.paramsToString("AnyTime", new object[]{(this.time).toDynamic()});
		}
		
		
		public readonly global::haxe.lang.Null<double> time;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys.thread {
	public sealed class NextEventTime_At : global::sys.thread.NextEventTime {
		
		public NextEventTime_At(double time) : base(3) {
			this.time = time;
		}
		
		
		public override global::Array<object> getParams() {
			return new global::Array<object>(new object[]{this.time});
		}
		
		
		public override string getTag() {
			return "At";
		}
		
		
		public override int GetHashCode() {
			unchecked {
				return global::haxe.lang.Enum.paramsGetHashCode(3, new object[]{this.time});
			}
		}
		
		
		public override bool Equals(object other) {
			if (global::System.Object.ReferenceEquals(((object) (this) ), ((object) (other) ))) {
				return true;
			}
			
			global::sys.thread.NextEventTime_At en = ( other as global::sys.thread.NextEventTime_At );
			if (( en == null )) {
				return false;
			}
			
			if ( ! (global::Type.enumEq<object>(((object) (this.time) ), ((object) (en.time) ))) ) {
				return false;
			}
			
			return true;
		}
		
		
		public override string toString() {
			return global::haxe.lang.Enum.paramsToString("At", new object[]{this.time});
		}
		
		
		public readonly double time;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys.thread {
	public class EventLoop : global::haxe.lang.HxObject {
		
		public EventLoop(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public EventLoop() {
			global::sys.thread.EventLoop.__hx_ctor_sys_thread_EventLoop(this);
		}
		
		
		protected static void __hx_ctor_sys_thread_EventLoop(global::sys.thread.EventLoop __hx_this) {
			__hx_this.promisedEventsCount = 0;
			__hx_this.waitLock = new global::sys.thread.Lock();
			__hx_this.oneTimeEventsIdx = 0;
			__hx_this.oneTimeEvents = new global::Array<object>();
			__hx_this.mutex = new global::sys.thread.Mutex();
			{
			}
			
		}
		
		
		public global::sys.thread.Mutex mutex;
		
		public global::Array<object> oneTimeEvents;
		
		public int oneTimeEventsIdx;
		
		public global::sys.thread.Lock waitLock;
		
		public int promisedEventsCount;
		
		public global::sys.thread._EventLoop.RegularEvent regularEvents;
		
		public virtual global::sys.thread._EventLoop.RegularEvent repeat(global::haxe.lang.Function @event, int intervalMs) {
			this.mutex.acquire();
			double interval = ( 0.001 * intervalMs );
			global::sys.thread._EventLoop.RegularEvent event1 = new global::sys.thread._EventLoop.RegularEvent(((global::haxe.lang.Function) (@event) ), ((double) (( global::Sys.time() + interval )) ), ((double) (interval) ));
			{
				global::sys.thread._EventLoop.RegularEvent _g = this.regularEvents;
				if (( _g == null )) {
				}
				else {
					global::sys.thread._EventLoop.RegularEvent current = _g;
					{
						event1.next = current;
						current.previous = event1;
					}
					
				}
				
			}
			
			this.regularEvents = event1;
			this.waitLock.release();
			this.mutex.release();
			return event1;
		}
		
		
		public virtual void cancel(global::sys.thread._EventLoop.RegularEvent eventHandler) {
			this.mutex.acquire();
			global::sys.thread._EventLoop.RegularEvent @event = eventHandler;
			if (( this.regularEvents == @event )) {
				this.regularEvents = @event.next;
			}
			
			{
				global::sys.thread._EventLoop.RegularEvent _g = @event.next;
				if (( _g == null )) {
				}
				else {
					global::sys.thread._EventLoop.RegularEvent e = _g;
					e.previous = @event.previous;
				}
				
			}
			
			{
				global::sys.thread._EventLoop.RegularEvent _g1 = @event.previous;
				if (( _g1 == null )) {
				}
				else {
					global::sys.thread._EventLoop.RegularEvent e1 = _g1;
					e1.next = @event.next;
				}
				
			}
			
			this.mutex.release();
		}
		
		
		public virtual void promise() {
			this.mutex.acquire();
			 ++ this.promisedEventsCount;
			this.mutex.release();
		}
		
		
		public virtual void run(global::haxe.lang.Function @event) {
			this.mutex.acquire();
			this.oneTimeEvents[this.oneTimeEventsIdx++] = @event;
			this.waitLock.release();
			this.mutex.release();
		}
		
		
		public virtual void runPromised(global::haxe.lang.Function @event) {
			this.mutex.acquire();
			this.oneTimeEvents[this.oneTimeEventsIdx++] = @event;
			 -- this.promisedEventsCount;
			this.waitLock.release();
			this.mutex.release();
		}
		
		
		public virtual global::sys.thread.NextEventTime progress() {
			unchecked {
				double now = global::Sys.time();
				global::Array<object> eventsToRun = new global::Array<object>(new object[]{});
				int eventsToRunIdx = 0;
				double nextEventAt = ((double) (-1) );
				this.mutex.acquire();
				while (this.waitLock.wait(new global::haxe.lang.Null<double>(0.0, true))) {
				}
				
				global::sys.thread._EventLoop.RegularEvent current = this.regularEvents;
				while (( current != null )) {
					if (( current.nextRunTime <= now )) {
						eventsToRun[eventsToRunIdx++] = current.run;
						current.nextRunTime += current.interval;
						nextEventAt = ((double) (-2) );
					}
					else if (( ( nextEventAt == -1 ) || ( current.nextRunTime < nextEventAt ) )) {
						nextEventAt = current.nextRunTime;
					}
					
					current = current.next;
				}
				
				this.mutex.release();
				int _g = 0;
				int _g1 = eventsToRunIdx;
				while (( _g < _g1 )) {
					int i = _g++;
					((global::haxe.lang.Function) (eventsToRun[i]) ).__hx_invoke0_o();
					eventsToRun[i] = null;
				}
				
				eventsToRunIdx = 0;
				this.mutex.acquire();
				int _g2_current = 0;
				global::Array<object> _g2_array = this.oneTimeEvents;
				while (( _g2_current < _g2_array.length )) {
					global::haxe.lang.Function _g3_value = ((global::haxe.lang.Function) (_g2_array[_g2_current]) );
					int _g3_key = _g2_current++;
					int i1 = _g3_key;
					global::haxe.lang.Function @event = _g3_value;
					if (( @event == null )) {
						break;
					}
					else {
						eventsToRun[eventsToRunIdx++] = @event;
						this.oneTimeEvents[i1] = null;
					}
					
				}
				
				this.oneTimeEventsIdx = 0;
				bool hasPromisedEvents = ( this.promisedEventsCount > 0 );
				this.mutex.release();
				int _g2 = 0;
				int _g3 = eventsToRunIdx;
				while (( _g2 < _g3 )) {
					int i2 = _g2++;
					((global::haxe.lang.Function) (eventsToRun[i2]) ).__hx_invoke0_o();
					eventsToRun[i2] = null;
				}
				
				if (( eventsToRunIdx > 0 )) {
					nextEventAt = ((double) (-2) );
				}
				
				double _g_nextEventAt = nextEventAt;
				bool _g_anyTime = hasPromisedEvents;
				bool _g4 = _g_anyTime;
				double _g5 = _g_nextEventAt;
				{
					double __temp_switch1 = (_g5);
					if (( __temp_switch1 == -2 )) {
						return global::sys.thread.NextEventTime.Now;
					}
					else if (( __temp_switch1 == -1 )) {
						if (_g4) {
							return global::sys.thread.NextEventTime.AnyTime(default(global::haxe.lang.Null<double>));
						}
						else {
							return global::sys.thread.NextEventTime.Never;
						}
						
					}
					else if (_g4) {
						double time = _g5;
						return global::sys.thread.NextEventTime.AnyTime(new global::haxe.lang.Null<double>(time, true));
					}
					else {
						double time1 = _g5;
						return global::sys.thread.NextEventTime.At(time1);
					}
					
				}
				
			}
		}
		
		
		public virtual bool wait(global::haxe.lang.Null<double> timeout) {
			return this.waitLock.wait(timeout);
		}
		
		
		public virtual void loop() {
			unchecked {
				global::Array<object> events = new global::Array<object>(new object[]{});
				while (true) {
					double now = global::Sys.time();
					global::Array<object> eventsToRun = events;
					int eventsToRunIdx = 0;
					double nextEventAt = ((double) (-1) );
					this.mutex.acquire();
					while (this.waitLock.wait(new global::haxe.lang.Null<double>(0.0, true))) {
					}
					
					global::sys.thread._EventLoop.RegularEvent current = this.regularEvents;
					while (( current != null )) {
						if (( current.nextRunTime <= now )) {
							eventsToRun[eventsToRunIdx++] = current.run;
							current.nextRunTime += current.interval;
							nextEventAt = ((double) (-2) );
						}
						else if (( ( nextEventAt == -1 ) || ( current.nextRunTime < nextEventAt ) )) {
							nextEventAt = current.nextRunTime;
						}
						
						current = current.next;
					}
					
					this.mutex.release();
					int _g = 0;
					int _g1 = eventsToRunIdx;
					while (( _g < _g1 )) {
						int i = _g++;
						((global::haxe.lang.Function) (eventsToRun[i]) ).__hx_invoke0_o();
						eventsToRun[i] = null;
					}
					
					eventsToRunIdx = 0;
					this.mutex.acquire();
					int _g2_current = 0;
					global::Array<object> _g2_array = this.oneTimeEvents;
					while (( _g2_current < _g2_array.length )) {
						global::haxe.lang.Function _g3_value = ((global::haxe.lang.Function) (_g2_array[_g2_current]) );
						int _g3_key = _g2_current++;
						int i1 = _g3_key;
						global::haxe.lang.Function @event = _g3_value;
						if (( @event == null )) {
							break;
						}
						else {
							eventsToRun[eventsToRunIdx++] = @event;
							this.oneTimeEvents[i1] = null;
						}
						
					}
					
					this.oneTimeEventsIdx = 0;
					bool hasPromisedEvents = ( this.promisedEventsCount > 0 );
					this.mutex.release();
					int _g2 = 0;
					int _g3 = eventsToRunIdx;
					while (( _g2 < _g3 )) {
						int i2 = _g2++;
						((global::haxe.lang.Function) (eventsToRun[i2]) ).__hx_invoke0_o();
						eventsToRun[i2] = null;
					}
					
					if (( eventsToRunIdx > 0 )) {
						nextEventAt = ((double) (-2) );
					}
					
					double r_nextEventAt = nextEventAt;
					bool r_anyTime = hasPromisedEvents;
					{
						bool _g4 = r_anyTime;
						double _g5 = r_nextEventAt;
						{
							double __temp_switch1 = (_g5);
							if (( __temp_switch1 == -2 )) {
							}
							else if (( __temp_switch1 == -1 )) {
								if (_g4) {
									this.waitLock.wait(default(global::haxe.lang.Null<double>));
								}
								else {
									goto label1;
								}
								
							}
							else {
								double time = _g5;
								{
									double timeout = ( time - global::Sys.time() );
									this.waitLock.wait(new global::haxe.lang.Null<double>(global::System.Math.Max(((double) (0) ), ((double) (timeout) )), true));
								}
								
							}
							
						}
						
					}
					
				}
				label1: {};
			}
		}
		
		
		public object __progress(double now, global::Array<object> recycle) {
			unchecked {
				global::Array<object> eventsToRun = recycle;
				int eventsToRunIdx = 0;
				double nextEventAt = ((double) (-1) );
				this.mutex.acquire();
				while (this.waitLock.wait(new global::haxe.lang.Null<double>(0.0, true))) {
				}
				
				global::sys.thread._EventLoop.RegularEvent current = this.regularEvents;
				while (( current != null )) {
					if (( current.nextRunTime <= now )) {
						eventsToRun[eventsToRunIdx++] = current.run;
						current.nextRunTime += current.interval;
						nextEventAt = ((double) (-2) );
					}
					else if (( ( nextEventAt == -1 ) || ( current.nextRunTime < nextEventAt ) )) {
						nextEventAt = current.nextRunTime;
					}
					
					current = current.next;
				}
				
				this.mutex.release();
				{
					int _g = 0;
					int _g1 = eventsToRunIdx;
					while (( _g < _g1 )) {
						int i = _g++;
						((global::haxe.lang.Function) (eventsToRun[i]) ).__hx_invoke0_o();
						eventsToRun[i] = null;
					}
					
				}
				
				eventsToRunIdx = 0;
				this.mutex.acquire();
				{
					int _g2_current = 0;
					global::Array<object> _g2_array = this.oneTimeEvents;
					while (( _g2_current < _g2_array.length )) {
						global::haxe.lang.Function _g3_value = ((global::haxe.lang.Function) (_g2_array[_g2_current]) );
						int _g3_key = _g2_current++;
						int i1 = _g3_key;
						global::haxe.lang.Function @event = _g3_value;
						if (( @event == null )) {
							break;
						}
						else {
							eventsToRun[eventsToRunIdx++] = @event;
							this.oneTimeEvents[i1] = null;
						}
						
					}
					
				}
				
				this.oneTimeEventsIdx = 0;
				bool hasPromisedEvents = ( this.promisedEventsCount > 0 );
				this.mutex.release();
				{
					int _g2 = 0;
					int _g3 = eventsToRunIdx;
					while (( _g2 < _g3 )) {
						int i2 = _g2++;
						((global::haxe.lang.Function) (eventsToRun[i2]) ).__hx_invoke0_o();
						eventsToRun[i2] = null;
					}
					
				}
				
				if (( eventsToRunIdx > 0 )) {
					nextEventAt = ((double) (-2) );
				}
				
				return new global::haxe.lang.DynamicObject(new int[]{540399897}, new object[]{hasPromisedEvents}, new int[]{1558459130}, new double[]{nextEventAt});
			}
		}
		
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 465747725:
					{
						this.promisedEventsCount = ((int) (@value) );
						return @value;
					}
					
					
					case 2036759185:
					{
						this.oneTimeEventsIdx = ((int) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 893862549:
					{
						this.regularEvents = ((global::sys.thread._EventLoop.RegularEvent) (@value) );
						return @value;
					}
					
					
					case 465747725:
					{
						this.promisedEventsCount = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1352270080:
					{
						this.waitLock = ((global::sys.thread.Lock) (@value) );
						return @value;
					}
					
					
					case 2036759185:
					{
						this.oneTimeEventsIdx = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 22835468:
					{
						this.oneTimeEvents = ((global::Array<object>) (global::Array<object>.__hx_cast<object>(((global::Array) (@value) ))) );
						return @value;
					}
					
					
					case 274435967:
					{
						this.mutex = ((global::sys.thread.Mutex) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 694381261:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "__progress", 694381261)) );
					}
					
					
					case 1203218020:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "loop", 1203218020)) );
					}
					
					
					case 1324505717:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "wait", 1324505717)) );
					}
					
					
					case 103479213:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "progress", 103479213)) );
					}
					
					
					case 925597908:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "runPromised", 925597908)) );
					}
					
					
					case 5695307:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "run", 5695307)) );
					}
					
					
					case 2011811227:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "promise", 2011811227)) );
					}
					
					
					case 942927226:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "cancel", 942927226)) );
					}
					
					
					case 108828507:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "repeat", 108828507)) );
					}
					
					
					case 893862549:
					{
						return this.regularEvents;
					}
					
					
					case 465747725:
					{
						return this.promisedEventsCount;
					}
					
					
					case 1352270080:
					{
						return this.waitLock;
					}
					
					
					case 2036759185:
					{
						return this.oneTimeEventsIdx;
					}
					
					
					case 22835468:
					{
						return this.oneTimeEvents;
					}
					
					
					case 274435967:
					{
						return this.mutex;
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 465747725:
					{
						return ((double) (this.promisedEventsCount) );
					}
					
					
					case 2036759185:
					{
						return ((double) (this.oneTimeEventsIdx) );
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, object[] dynargs) {
			unchecked {
				switch (hash) {
					case 694381261:
					{
						return this.__progress(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ), ((global::Array<object>) (global::Array<object>.__hx_cast<object>(((global::Array) (dynargs[1]) ))) ));
					}
					
					
					case 1203218020:
					{
						this.loop();
						break;
					}
					
					
					case 1324505717:
					{
						return this.wait(global::haxe.lang.Null<object>.ofDynamic<double>(( (( dynargs.Length > 0 )) ? (dynargs[0]) : (null) )));
					}
					
					
					case 103479213:
					{
						return this.progress();
					}
					
					
					case 925597908:
					{
						this.runPromised(((global::haxe.lang.Function) (dynargs[0]) ));
						break;
					}
					
					
					case 5695307:
					{
						this.run(((global::haxe.lang.Function) (dynargs[0]) ));
						break;
					}
					
					
					case 2011811227:
					{
						this.promise();
						break;
					}
					
					
					case 942927226:
					{
						this.cancel(((global::sys.thread._EventLoop.RegularEvent) (dynargs[0]) ));
						break;
					}
					
					
					case 108828507:
					{
						return this.repeat(((global::haxe.lang.Function) (dynargs[0]) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[1])) ));
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
		public override void __hx_getFields(global::Array<string> baseArr) {
			baseArr.push("regularEvents");
			baseArr.push("promisedEventsCount");
			baseArr.push("waitLock");
			baseArr.push("oneTimeEventsIdx");
			baseArr.push("oneTimeEvents");
			baseArr.push("mutex");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys.thread._EventLoop {
	public class RegularEvent : global::haxe.lang.HxObject {
		
		public RegularEvent(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public RegularEvent(global::haxe.lang.Function run, double nextRunTime, double interval) {
			global::sys.thread._EventLoop.RegularEvent.__hx_ctor_sys_thread__EventLoop_RegularEvent(this, run, nextRunTime, interval);
		}
		
		
		protected static void __hx_ctor_sys_thread__EventLoop_RegularEvent(global::sys.thread._EventLoop.RegularEvent __hx_this, global::haxe.lang.Function run, double nextRunTime, double interval) {
			__hx_this.run = run;
			__hx_this.nextRunTime = nextRunTime;
			__hx_this.interval = interval;
		}
		
		
		public double nextRunTime;
		
		public double interval;
		
		public global::haxe.lang.Function run;
		
		public global::sys.thread._EventLoop.RegularEvent next;
		
		public global::sys.thread._EventLoop.RegularEvent previous;
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 679246149:
					{
						this.interval = ((double) (@value) );
						return @value;
					}
					
					
					case 813914181:
					{
						this.nextRunTime = ((double) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 598785079:
					{
						this.previous = ((global::sys.thread._EventLoop.RegularEvent) (@value) );
						return @value;
					}
					
					
					case 1224901875:
					{
						this.next = ((global::sys.thread._EventLoop.RegularEvent) (@value) );
						return @value;
					}
					
					
					case 5695307:
					{
						this.run = ((global::haxe.lang.Function) (@value) );
						return @value;
					}
					
					
					case 679246149:
					{
						this.interval = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 813914181:
					{
						this.nextRunTime = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 598785079:
					{
						return this.previous;
					}
					
					
					case 1224901875:
					{
						return this.next;
					}
					
					
					case 5695307:
					{
						return this.run;
					}
					
					
					case 679246149:
					{
						return this.interval;
					}
					
					
					case 813914181:
					{
						return this.nextRunTime;
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 679246149:
					{
						return this.interval;
					}
					
					
					case 813914181:
					{
						return this.nextRunTime;
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override void __hx_getFields(global::Array<string> baseArr) {
			baseArr.push("previous");
			baseArr.push("next");
			baseArr.push("run");
			baseArr.push("interval");
			baseArr.push("nextRunTime");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


