// Generated by Haxe 4.2.2
package haxe.ds;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class BalancedTree<K, V> extends haxe.lang.HxObject implements haxe.IMap<K, V>
{
	public BalancedTree(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public BalancedTree()
	{
		//line 41 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.ds.BalancedTree.__hx_ctor_haxe_ds_BalancedTree(((haxe.ds.BalancedTree<K, V>) (this) ));
		//line 41 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		java.lang.Object __temp_expr1 = ((java.lang.Object) (null) );
	}
	
	
	protected static <K_c, V_c> void __hx_ctor_haxe_ds_BalancedTree(haxe.ds.BalancedTree<K_c, V_c> __hx_this)
	{
	}
	
	
	public static <K1, V2> void iteratorLoop(haxe.ds.TreeNode<K1, V2> node, haxe.root.Array<V2> acc)
	{
		//line 173 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( node != null )) 
		{
			//line 174 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			haxe.ds.BalancedTree.iteratorLoop(((haxe.ds.TreeNode<K1, V2>) (node.left) ), ((haxe.root.Array<V2>) (acc) ));
			//line 174 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			java.lang.Object __temp_expr1 = ((java.lang.Object) (null) );
			//line 175 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			acc.push(node.value);
			//line 176 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			haxe.ds.BalancedTree.iteratorLoop(((haxe.ds.TreeNode<K1, V2>) (node.right) ), ((haxe.root.Array<V2>) (acc) ));
			//line 176 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			java.lang.Object __temp_expr2 = ((java.lang.Object) (null) );
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> root;
	
	public void set(K key, V value)
	{
		//line 51 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		this.root = this.setLoop(key, value, this.root);
	}
	
	
	public java.lang.Object get(K key)
	{
		//line 62 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.ds.TreeNode<K, V> node = this.root;
		//line 63 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		while (( node != null ))
		{
			//line 64 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			int c = this.compare(key, node.key);
			//line 65 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( c == 0 )) 
			{
				//line 66 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return node.value;
			}
			
			//line 67 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( c < 0 )) 
			{
				//line 68 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				node = node.left;
			}
			else
			{
				//line 70 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				node = node.right;
			}
			
		}
		
		//line 72 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return null;
	}
	
	
	public boolean remove(K key)
	{
		//line 86 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		try 
		{
			//line 86 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			try 
			{
				//line 87 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				this.root = this.removeLoop(key, this.root);
				//line 88 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return true;
			}
			catch (java.lang.Throwable _g)
			{
				//line 89 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				{
					//line 89 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
					haxe.NativeStackTrace.exception.set(((java.lang.Throwable) (_g) ));
				}
				
				//line 86 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				if (( ((java.lang.Object) (haxe.Exception.caught(_g).unwrap()) ) instanceof java.lang.String )) 
				{
					//line 90 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
					return false;
				}
				else
				{
					//line 86 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
					throw _g;
				}
				
			}
			
			
		}
		catch (java.lang.Throwable typedException)
		{
			//line 85 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			throw ((java.lang.RuntimeException) (haxe.Exception.thrown(typedException)) );
		}
		
		
	}
	
	
	public boolean exists(K key)
	{
		//line 102 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.ds.TreeNode<K, V> node = this.root;
		//line 103 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		while (( node != null ))
		{
			//line 104 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			int c = this.compare(key, node.key);
			//line 105 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( c == 0 )) 
			{
				//line 106 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return true;
			}
			else
			{
				//line 107 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				if (( c < 0 )) 
				{
					//line 108 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
					node = node.left;
				}
				else
				{
					//line 110 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
					node = node.right;
				}
				
			}
			
		}
		
		//line 112 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return false;
	}
	
	
	public java.lang.Object iterator()
	{
		//line 121 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.root.Array<V> ret = new haxe.root.Array<V>(( (V[]) (new java.lang.Object[] {}) ));
		//line 122 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.ds.BalancedTree.iteratorLoop(((haxe.ds.TreeNode<K, V>) (this.root) ), ((haxe.root.Array<V>) (ret) ));
		//line 122 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		java.lang.Object __temp_expr1 = ((java.lang.Object) (null) );
		//line 123 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return new haxe.iterators.ArrayIterator<V>(((haxe.root.Array<V>) (ret) ));
	}
	
	
	public final java.lang.Object keyValueIterator()
	{
		//line 130 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return new haxe.iterators.MapKeyValueIterator<K, V>(((haxe.IMap<K, V>) (this) ));
	}
	
	
	public java.lang.Object keys()
	{
		//line 139 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.root.Array<K> ret = new haxe.root.Array<K>(( (K[]) (new java.lang.Object[] {}) ));
		//line 140 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		this.keysLoop(this.root, ret);
		//line 141 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return new haxe.iterators.ArrayIterator<K>(((haxe.root.Array<K>) (ret) ));
	}
	
	
	public haxe.ds.BalancedTree<K, V> copy()
	{
		//line 145 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.ds.BalancedTree<K, V> copied = new haxe.ds.BalancedTree<K, V>();
		//line 146 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		copied.root = this.root;
		//line 147 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return copied;
	}
	
	
	public haxe.ds.TreeNode<K, V> setLoop(K k, V v, haxe.ds.TreeNode<K, V> node)
	{
		//line 151 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( node == null )) 
		{
			//line 152 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (null) ), ((K) (k) ), ((V) (v) ), ((haxe.ds.TreeNode<K, V>) (null) ), ((java.lang.Object) (null) ));
		}
		
		//line 153 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		int c = this.compare(k, node.key);
		//line 154 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( c == 0 )) 
		{
			//line 154 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (node.left) ), ((K) (k) ), ((V) (v) ), ((haxe.ds.TreeNode<K, V>) (node.right) ), ((java.lang.Object) (( (( node == null )) ? (0) : (node._height) )) ));
		}
		else
		{
			//line 154 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( c < 0 )) 
			{
				//line 155 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				haxe.ds.TreeNode<K, V> nl = this.setLoop(k, v, node.left);
				//line 156 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return this.balance(nl, node.key, node.value, node.right);
			}
			else
			{
				//line 158 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				haxe.ds.TreeNode<K, V> nr = this.setLoop(k, v, node.right);
				//line 159 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return this.balance(node.left, node.key, node.value, nr);
			}
			
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> removeLoop(K k, haxe.ds.TreeNode<K, V> node)
	{
		//line 164 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( node == null )) 
		{
			//line 165 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			throw ((java.lang.RuntimeException) (haxe.Exception.thrown("Not_found")) );
		}
		
		//line 166 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		int c = this.compare(k, node.key);
		//line 167 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( c == 0 )) 
		{
			//line 167 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return this.merge(node.left, node.right);
		}
		else
		{
			//line 168 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( c < 0 )) 
			{
				//line 168 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return this.balance(this.removeLoop(k, node.left), node.key, node.value, node.right);
			}
			else
			{
				//line 169 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return this.balance(node.left, node.key, node.value, this.removeLoop(k, node.right));
			}
			
		}
		
	}
	
	
	public void keysLoop(haxe.ds.TreeNode<K, V> node, haxe.root.Array<K> acc)
	{
		//line 181 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( node != null )) 
		{
			//line 182 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			this.keysLoop(node.left, acc);
			//line 183 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			acc.push(node.key);
			//line 184 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			this.keysLoop(node.right, acc);
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> merge(haxe.ds.TreeNode<K, V> t1, haxe.ds.TreeNode<K, V> t2)
	{
		//line 189 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( t1 == null )) 
		{
			//line 190 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return t2;
		}
		
		//line 191 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( t2 == null )) 
		{
			//line 192 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return t1;
		}
		
		//line 193 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		haxe.ds.TreeNode<K, V> t = this.minBinding(t2);
		//line 194 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return this.balance(t1, t.key, t.value, this.removeMinBinding(t2));
	}
	
	
	public haxe.ds.TreeNode<K, V> minBinding(haxe.ds.TreeNode<K, V> t)
	{
		//line 198 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( t == null )) 
		{
			//line 198 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			throw ((java.lang.RuntimeException) (haxe.Exception.thrown("Not_found")) );
		}
		else
		{
			//line 198 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( t.left == null )) 
			{
				//line 198 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return t;
			}
			else
			{
				//line 198 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return this.minBinding(t.left);
			}
			
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> removeMinBinding(haxe.ds.TreeNode<K, V> t)
	{
		//line 202 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( t.left == null )) 
		{
			//line 202 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return t.right;
		}
		else
		{
			//line 202 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return this.balance(this.removeMinBinding(t.left), t.key, t.value, t.right);
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> balance(haxe.ds.TreeNode<K, V> l, K k, V v, haxe.ds.TreeNode<K, V> r)
	{
		//line 206 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		int hl = ( (( l == null )) ? (0) : (l._height) );
		//line 207 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		int hr = ( (( r == null )) ? (0) : (r._height) );
		//line 208 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( hl > ( hr + 2 ) )) 
		{
			//line 209 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			haxe.ds.TreeNode<K, V> _this = l.left;
			//line 209 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			haxe.ds.TreeNode<K, V> _this1 = l.right;
			//line 209 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( (( (( _this == null )) ? (0) : (_this._height) )) >= (( (( _this1 == null )) ? (0) : (_this1._height) )) )) 
			{
				//line 210 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (l.left) ), ((K) (l.key) ), ((V) (l.value) ), ((haxe.ds.TreeNode<K, V>) (new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (l.right) ), ((K) (k) ), ((V) (v) ), ((haxe.ds.TreeNode<K, V>) (r) ), ((java.lang.Object) (null) ))) ), ((java.lang.Object) (null) ));
			}
			else
			{
				//line 212 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (l.left) ), ((K) (l.key) ), ((V) (l.value) ), ((haxe.ds.TreeNode<K, V>) (l.right.left) ), ((java.lang.Object) (null) ))) ), ((K) (l.right.key) ), ((V) (l.right.value) ), ((haxe.ds.TreeNode<K, V>) (new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (l.right.right) ), ((K) (k) ), ((V) (v) ), ((haxe.ds.TreeNode<K, V>) (r) ), ((java.lang.Object) (null) ))) ), ((java.lang.Object) (null) ));
			}
			
		}
		else
		{
			//line 214 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( hr > ( hl + 2 ) )) 
			{
				//line 215 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				haxe.ds.TreeNode<K, V> _this2 = r.right;
				//line 215 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				haxe.ds.TreeNode<K, V> _this3 = r.left;
				//line 215 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				if (( (( (( _this2 == null )) ? (0) : (_this2._height) )) > (( (( _this3 == null )) ? (0) : (_this3._height) )) )) 
				{
					//line 216 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
					return new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (l) ), ((K) (k) ), ((V) (v) ), ((haxe.ds.TreeNode<K, V>) (r.left) ), ((java.lang.Object) (null) ))) ), ((K) (r.key) ), ((V) (r.value) ), ((haxe.ds.TreeNode<K, V>) (r.right) ), ((java.lang.Object) (null) ));
				}
				else
				{
					//line 218 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
					return new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (l) ), ((K) (k) ), ((V) (v) ), ((haxe.ds.TreeNode<K, V>) (r.left.left) ), ((java.lang.Object) (null) ))) ), ((K) (r.left.key) ), ((V) (r.left.value) ), ((haxe.ds.TreeNode<K, V>) (new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (r.left.right) ), ((K) (r.key) ), ((V) (r.value) ), ((haxe.ds.TreeNode<K, V>) (r.right) ), ((java.lang.Object) (null) ))) ), ((java.lang.Object) (null) ));
				}
				
			}
			else
			{
				//line 221 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return new haxe.ds.TreeNode<K, V>(((haxe.ds.TreeNode<K, V>) (l) ), ((K) (k) ), ((V) (v) ), ((haxe.ds.TreeNode<K, V>) (r) ), ((java.lang.Object) (( (( (( hl > hr )) ? (hl) : (hr) )) + 1 )) ));
			}
			
		}
		
	}
	
	
	public int compare(K k1, K k2)
	{
		//line 226 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return ((int) (haxe.root.Reflect.compare(((K) (k1) ), ((K) (k2) ))) );
	}
	
	
	@Override public java.lang.String toString()
	{
		//line 230 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		if (( this.root == null )) 
		{
			//line 230 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return "{}";
		}
		else
		{
			//line 230 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			return ( ( "{" + this.root.toString() ) + "}" );
		}
		
	}
	
	
	public void clear()
	{
		//line 237 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		this.root = null;
	}
	
	
	@Override public java.lang.Object __hx_setField(java.lang.String field, java.lang.Object value, boolean handleProperties)
	{
		//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		{
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			boolean __temp_executeDef1 = true;
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( field != null )) 
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				switch (field.hashCode())
				{
					case 3506402:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("root")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							this.root = ((haxe.ds.TreeNode<K, V>) (value) );
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return value;
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
				}
				
			}
			
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (__temp_executeDef1) 
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return super.__hx_setField(field, value, handleProperties);
			}
			else
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_getField(java.lang.String field, boolean throwErrors, boolean isCheck, boolean handleProperties)
	{
		//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		{
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			boolean __temp_executeDef1 = true;
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( field != null )) 
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				switch (field.hashCode())
				{
					case 94746189:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("clear")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "clear")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 3506402:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("root")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.root;
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -1776922004:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("toString")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "toString")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 113762:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("set")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "set")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 950484197:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("compare")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "compare")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 102230:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("get")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "get")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -339185956:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("balance")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "balance")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -934610812:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("remove")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "remove")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 277888887:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("removeMinBinding")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "removeMinBinding")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -1289358244:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("exists")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "exists")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -757252141:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("minBinding")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "minBinding")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 1182533742:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("iterator")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "iterator")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 103785528:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("merge")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "merge")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -955047712:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("keyValueIterator")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "keyValueIterator")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 518409912:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("keysLoop")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "keysLoop")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 3288564:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("keys")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "keys")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 1098338632:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("removeLoop")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "removeLoop")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 3059573:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("copy")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "copy")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 1984755238:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("setLoop")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "setLoop")) );
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
				}
				
			}
			
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (__temp_executeDef1) 
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return super.__hx_getField(field, throwErrors, isCheck, handleProperties);
			}
			else
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_invokeField(java.lang.String field, java.lang.Object[] dynargs)
	{
		//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		{
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			boolean __temp_executeDef1 = true;
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (( field != null )) 
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				switch (field.hashCode())
				{
					case 94746189:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("clear")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							this.clear();
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 113762:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("set")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							this.set(((K) (dynargs[0]) ), ((V) (dynargs[1]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -1776922004:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("toString")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.toString();
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 102230:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("get")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.get(((K) (dynargs[0]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 950484197:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("compare")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.compare(((K) (dynargs[0]) ), ((K) (dynargs[1]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -934610812:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("remove")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.remove(((K) (dynargs[0]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -339185956:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("balance")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.balance(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ), ((K) (dynargs[1]) ), ((V) (dynargs[2]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[3]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -1289358244:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("exists")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.exists(((K) (dynargs[0]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 277888887:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("removeMinBinding")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.removeMinBinding(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 1182533742:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("iterator")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.iterator();
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -757252141:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("minBinding")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.minBinding(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case -955047712:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("keyValueIterator")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.keyValueIterator();
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 103785528:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("merge")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.merge(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[1]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 3288564:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("keys")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.keys();
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 518409912:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("keysLoop")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							this.keysLoop(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ), ((haxe.root.Array<K>) (dynargs[1]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 3059573:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("copy")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.copy();
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 1098338632:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("removeLoop")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.removeLoop(((K) (dynargs[0]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[1]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
					case 1984755238:
					{
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						if (field.equals("setLoop")) 
						{
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
							return this.setLoop(((K) (dynargs[0]) ), ((V) (dynargs[1]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[2]) ));
						}
						
						//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
						break;
					}
					
					
				}
				
			}
			
			//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
			if (__temp_executeDef1) 
			{
				//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
				return super.__hx_invokeField(field, dynargs);
			}
			
		}
		
		//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		return null;
	}
	
	
	@Override public void __hx_getFields(haxe.root.Array<java.lang.String> baseArr)
	{
		//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		baseArr.push("root");
		//line 35 "C:\\HaxeToolkit\\haxe\\std\\haxe\\ds\\BalancedTree.hx"
		super.__hx_getFields(baseArr);
	}
	
	
}


