// Generated by Haxe 4.2.2

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldHashConflict {
		
		public FieldHashConflict(int hash, string name, object @value, global::haxe.lang.FieldHashConflict next) {
			this.hash = hash;
			this.name = name;
			this.@value = @value;
			this.next = next;
		}
		
		
		public readonly int hash;
		
		public readonly string name;
		
		public object @value;
		
		public global::haxe.lang.FieldHashConflict next;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{98, 101, 104, 105, 109, 110, 113, 114, 115, 116, 118, 22848, 22862, 23072, 23296, 23520, 23526, 23527, 23977, 24414, 24422, 25979, 1332402, 1821933, 4745537, 4816701, 4846113, 4849249, 4896967, 4899635, 4947588, 4949376, 4995541, 4996429, 4997752, 5047484, 5049505, 5098559, 5144726, 5145602, 5194459, 5243965, 5246186, 5343647, 5393365, 5442204, 5442212, 5443986, 5541879, 5544103, 5545010, 5545011, 5593173, 5594513, 5594516, 5691745, 5693967, 5695307, 5741474, 5744817, 5745024, 5790526, 5841808, 5843823, 5991895, 9342585, 9671866, 10319920, 10663594, 14532012, 22835468, 24046298, 25738091, 33736073, 40034999, 42740551, 43737796, 46374763, 47121374, 50254234, 52644165, 52892584, 57219237, 60289868, 63190583, 64142247, 66662680, 67856200, 67859554, 68006728, 71871848, 72252782, 75232702, 76061764, 78945784, 87367608, 88678082, 95523933, 96903864, 103479213, 104493173, 108828507, 110661850, 110941857, 112843575, 116222917, 123315877, 125111323, 125916185, 127488538, 132916898, 133414859, 142151465, 142301684, 142605435, 155596155, 157772329, 159136996, 162003290, 172955042, 179047623, 179179016, 184980232, 184980900, 188431961, 191923584, 194144585, 207609411, 208459108, 209784577, 211851220, 212244564, 212892678, 221637784, 222029606, 225290809, 225347491, 226931207, 234584065, 243225909, 244830897, 247036618, 247969072, 252173918, 252174139, 252174360, 253048465, 260487219, 261031087, 262801146, 269666874, 274435967, 276573010, 281751194, 282360088, 288167040, 293985672, 294620923, 300357466, 302979532, 305151978, 306633900, 309502035, 310553184, 311106773, 311106994, 312752480, 315144466, 328878574, 334695532, 336134320, 336409195, 336655392, 338395897, 339281328, 343868310, 350619104, 350619108, 353204262, 358990357, 359333139, 360725482, 364006368, 365188593, 376065817, 376275830, 380244791, 383765703, 384816719, 388680308, 389426697, 391139962, 391262694, 391692349, 393324759, 395673374, 398798074, 400509660, 404153790, 407283053, 408610927, 415668218, 428136415, 429147631, 429185260, 429915128, 437335495, 440931783, 444663929, 446171152, 449540217, 451001976, 452737314, 454875113, 461513450, 465747725, 466736821, 474209209, 474773467, 476102071, 480756972, 481768284, 488637228, 491925868, 493819893, 497620822, 499574632, 501039929, 502768344, 502769015, 508959438, 520590566, 520665567, 525508230, 528448451, 528773354, 529244784, 533842310, 537630174, 540399897, 541033283, 542823803, 552686987, 555164043, 572311959, 578355141, 583988803, 589000550, 589599061, 590345008, 591404329, 596483356, 598785079, 601741370, 603885322, 605915487, 607880558, 610723709, 614073432, 618537130, 630156697, 631713332, 633407693, 634786275, 637231206, 640252688, 645255902, 650414942, 651840319, 651890926, 652696899, 652994848, 660670753, 664175990, 666925948, 671590589, 675998584, 679246149, 682095612, 688014215, 691028628, 694381261, 701410669, 703544457, 712301447, 716544785, 723690193, 724060212, 725786923, 725788697, 727112898, 727985871, 735461151, 742854407, 744003798, 744358035, 746281503, 748543309, 756413782, 759140663, 772311838, 772312059, 775122645, 777789860, 782495260, 784433846, 790737991, 792687011, 798803052, 803799311, 810689960, 813914181, 821570219, 822313068, 825712952, 826550065, 832635986, 834174833, 838796847, 839165814, 843917434, 845179051, 847075774, 849624764, 855644584, 855935792, 863972113, 877441228, 878103594, 885141049, 887376854, 888960333, 889051340, 891567758, 893862549, 896658202, 910198946, 912604165, 922037898, 922671056, 925597908, 930693872, 930986349, 930987020, 936714910, 937143178, 937267591, 941338270, 942927226, 943988923, 944645571, 945294764, 946786476, 951250957, 952878022, 982974890, 983233609, 988470062, 994020274, 995006396, 997465939, 1002832288, 1007673663, 1008670959, 1016047850, 1021796563, 1024542152, 1027177476, 1029013645, 1033373803, 1039653363, 1040745046, 1042138122, 1042869219, 1049971873, 1051591445, 1054351781, 1055698607, 1056887089, 1058459579, 1058556349, 1063066675, 1066567601, 1066783641, 1067353468, 1071652316, 1072490607, 1072885311, 1081380189, 1083890296, 1087583404, 1091627025, 1091869250, 1092023741, 1092171829, 1092319906, 1092323692, 1093477314, 1095840978, 1100981319, 1102715038, 1103060694, 1103359965, 1103412149, 1113806382, 1113807511, 1114201093, 1116398082, 1125041792, 1126038837, 1126235833, 1126920507, 1126941888, 1134340117, 1135011784, 1135722850, 1136381564, 1136381571, 1136829802, 1136978772, 1137315269, 1138177110, 1139639992, 1145554120, 1149558607, 1151917883, 1153194234, 1154932936, 1155848147, 1156121931, 1158359328, 1158860648, 1164701600, 1164821372, 1167534896, 1169594568, 1169850080, 1169898256, 1169995914, 1170195731, 1171620962, 1173624273, 1177754921, 1181037546, 1191633396, 1191829406, 1191829844, 1192939994, 1193841030, 1196428959, 1202522710, 1202718727, 1202919412, 1202919418, 1203028895, 1203218020, 1204059472, 1204816148, 1208244040, 1212528822, 1213811397, 1213952397, 1214305123, 1214452573, 1214453688, 1216198099, 1224700491, 1224901644, 1224901875, 1225098545, 1227765365, 1230265810, 1231639053, 1233348025, 1233646036, 1238331169, 1238832007, 1242623863, 1245948379, 1246881189, 1247076770, 1247473716, 1247475490, 1247576961, 1247723251, 1247875546, 1254379272, 1257164128, 1257939113, 1258363366, 1267426050, 1269206179, 1269254998, 1269755426, 1271070480, 1273207865, 1274465926, 1274838865, 1274863514, 1275479599, 1275922997, 1280345464, 1280549057, 1280638028, 1280638699, 1280842308, 1280845662, 1281093634, 1282943179, 1291235454, 1291436593, 1292432058, 1302870512, 1309344294, 1311059210, 1312666830, 1313416818, 1313418156, 1315911912, 1317134924, 1324265963, 1324505717, 1326984057, 1337394146, 1348037855, 1352270080, 1352786672, 1353009689, 1359591923, 1367480579, 1371405953, 1375221624, 1381630732, 1386303363, 1390395051, 1390578741, 1390578962, 1390579183, 1395555037, 1400771174, 1406510796, 1407096607, 1417081766, 1420772493, 1439849010, 1441685007, 1443990783, 1445635792, 1450762973, 1460447810, 1462366467, 1463210438, 1483922940, 1484998194, 1488000822, 1488620307, 1489662016, 1490626689, 1491961287, 1499183351, 1503920168, 1505719464, 1512997393, 1519236735, 1520135451, 1521873482, 1529612153, 1532710347, 1533657591, 1537812987, 1543410694, 1547440149, 1547539107, 1549276146, 1554480847, 1557350120, 1558459130, 1560893070, 1567884407, 1576149820, 1582403597, 1601245343, 1614780307, 1617601604, 1617880893, 1620824029, 1621420777, 1623148745, 1637368501, 1638461456, 1639293562, 1648581351, 1650950685, 1651365158, 1661489734, 1671072698, 1673824922, 1691023565, 1693277929, 1694328968, 1695633562, 1696501554, 1705565617, 1705629508, 1710323747, 1717370737, 1723805383, 1729636910, 1734349548, 1750981280, 1756866521, 1757972228, 1763375486, 1768164316, 1771684955, 1773615436, 1774616421, 1786966140, 1789423016, 1789945678, 1792245274, 1794072594, 1795947670, 1797027058, 1797028832, 1797611211, 1815309403, 1815533258, 1817623149, 1818990145, 1822159017, 1825849507, 1828505873, 1828713895, 1830181323, 1830310359, 1836776262, 1836975402, 1837892969, 1840387740, 1840455391, 1845303376, 1848869397, 1849631693, 1855145886, 1864494649, 1869704293, 1873474154, 1878640711, 1879807530, 1886001471, 1887596712, 1889717695, 1891834246, 1893491216, 1894423562, 1895567566, 1898155939, 1900716655, 1907251402, 1909323791, 1915412854, 1916009602, 1918417798, 1920084442, 1920782701, 1932118984, 1935704942, 1937159360, 1940399131, 1960373088, 1962040800, 1970444429, 1981972957, 1982509203, 1987394228, 1988514268, 1993152491, 1997282830, 1998628419, 2003447495, 2005380545, 2010580328, 2011811227, 2012934199, 2022294396, 2025055113, 2025238049, 2029008698, 2029227650, 2030363417, 2034790270, 2036759185, 2039910769, 2045446969, 2048392659, 2056840295, 2057163599, 2063384608, 2063484673, 2069384610, 2079583163, 2081356408, 2082268609, 2082663554, 2083310240, 2083500811, 2090419204, 2095388591, 2103468489, 2113708439, 2123232567, 2127021138, 2131770120, 2143813817, 2146961862};
		
		protected static string[] fields = new string[]{"b", "e", "h", "i", "m", "n", "q", "r", "s", "t", "v", "ff", "ft", "gg", "hh", "ii", "io", "ip", "kt", "mk", "ms", "to", "get_position", "isGlobal", "__a", "currentLoop", "add", "arr", "bin", "buf", "cmn", "cur", "dev", "dir", "doc", "eof", "ext", "fun", "get", "gid", "hex", "idx", "ino", "key", "len", "map", "max", "min", "obj", "old", "ops", "opt", "pin", "pop", "pos", "ret", "rol", "run", "set", "str", "sub", "tbl", "uid", "url", "xml", "fields", "field", "first", "postData", "resolveClass", "oneTimeEvents", "split", "exitCode", "saveVars", "variables", "flags", "flush", "readAll", "readPos", "opRightAssoc", "match", "maybe", "compare", "firstChild", "elements", "syncFlag", "setEvent", "stack", "start", "stdin", "parseFunctionArgs", "helper", "ensure", "remove", "__previousException", "filter", "parseMetadata", "decodeBytes", "merge", "progress", "parseFunctionDecl", "repeat", "makeBinop", "xenumfield", "hxUnserialize", "exprReturn", "setGlobal", "hashCode", "subarray", "waitCount", "stderr", "stdout", "classString", "resize", "useCache", "addType", "onError", "matched", "xabstract", "getFullYear", "readString", "tryUnify", "accept", "access", "getHours", "parseStructure", "parseModuleDecl", "isEmpty", "parseString", "output", "nstrings", "newline", "resolver", "__nativeException", "setLoop", "isPrivate", "insertChild", "getString", "doEncode", "readBytes", "compareArg", "thread", "assignOp", "readInt16", "readInt24", "readInt32", "getUTCMinutes", "curplatform", "get_length", "mtime", "_token", "mutex", "parseObject", "setFloat", "allowMetadata", "stream", "releaseCount", "getValue", "tokens", "methodName", "hostEntry", "preprocess", "setDouble", "platforms", "readUInt16", "readUInt24", "get_native", "ignore", "iterator", "indent", "hxSerialize", "toCps", "toHex", "token", "globals", "dateUTC", "getData", "getDate", "set_position", "getUInt16", "lastIndexOf", "connect", "attributeMap", "getUTCSeconds", "events", "getTopLevelEnd", "readChunk", "removeGlobal", "serializeException", "nbits", "get_LogFolder", "getIdent", "get_nodeValue", "writeFloat", "attributes", "getHost", "constructor", "totlen", "replacer", "hasNext", "isInterface", "xclassfield", "asyncIdents", "mergeRights", "evalAssignOp", "xtypeparams", "message", "fileTransfer", "serializeFields", "positionAtLine", "types", "keysLoop", "reverse", "setPostBytes", "getNano", "promisedEventsCount", "typeExprWith", "addme", "tryAcquire", "parseFullExpr", "nOccupied", "parseNumber", "isFinal", "defineVar", "getBytes", "doDecodeInt", "nlink", "insert", "getInt32", "getInt64", "mergeClasses", "length", "addSub", "unserializeObject", "getTime", "isExtern", "getType", "typeToString", "get_message", "anyTime", "checkSync", "bigEndian", "tdynamic", "duplicate", "native", "saveLocals", "unasync", "getDay", "getPid", "get_ip", "getMinutes", "balance", "previous", "newField", "useEnumIndex", "sendMessage", "apply", "writeFullBytes", "matchedRight", "tokenString", "array", "defplat", "allowUntypedMeta", "hasOnData", "tokenComment", "writeString", "initTable", "set_bigEndian", "athis", "atime", "unify", "invalidNumber", "chunk_buf", "get_nodeName", "getUTCDate", "superClass", "preprocValue", "interval", "opChars", "encodeString", "constString", "__progress", "invalidChar", "getSeconds", "parseField", "localParams", "serializeString", "replace", "tokenMax", "tokenMin", "details", "hours", "setTimeout", "readDouble", "get_Code", "CurrentDeployEnvironment", "contains", "Code", "emptyOnData", "typeArgs", "writeUInt16", "writeUInt24", "curExpr", "allowDefine", "readDigits", "pretty", "getDouble", "implement", "firstElement", "typeExpr", "evalPreproCond", "nextRunTime", "randomByte", "setPostData", "resumeErrors", "allowJSON", "setValuefromBytes", "value", "increment", "mapType", "mergeEnums", "quotient", "callAsync", "getResolver", "binop", "bitOR", "__nativeStack", "lockObj", "fieldsString", "constructors", "acquire", "block", "messages", "addHeader", "regularEvents", "hstrings", "compareArgs", "statics", "addBytes", "cachedIndex", "runPromised", "ident", "addInt32", "addInt64", "isAsyncIdent", "doDecodeConst", "prepare", "mkTypeParams", "cancel", "byteOffset", "success", "makeCall", "toString", "processElement", "setFastSend", "doWhileLoop", "scriptCall", "build", "doEncodeString", "hashes", "serializeRef", "mergeTypedefs", "parseModule", "scache", "set_nodeName", "releaseEvent", "setResolver", "addXmlApi", "param", "bytes", "callValue", "inTry", "input", "makeXmlType", "returnValue", "mkRights", "opPriority", "canWrite", "makeMono", "addChild", "_eof", "isPublic", "custom", "__exceptionStack", "splice", "exists", "setValue", "equals", "args", "_doDecode", "module", "base", "cache", "bind", "blit", "body", "bout", "allowGlobalsDefine", "isMap", "mapCompr", "call", "char", "cnew", "copy", "date", "days", "diff", "elementsNamed", "edef", "expr", "hasChildren", "matchSub", "xclass", "definedVars", "makeType", "classField", "file", "fill", "from", "funs", "responseHeaders", "isOverride", "removeChild", "makeUnop", "request", "storage", "declared", "removeLoop", "minBinding", "responseData", "head", "host", "typeField", "scount", "allowTypes", "check", "impl", "init", "ipad", "item", "getTimezoneOffset", "unexpected", "__skipStack", "join", "keys", "kill", "kind", "extend", "currentFun", "readHttpResponse", "last", "left", "line", "link", "get_stack", "loop", "writeDouble", "concat", "addParameter", "backslash", "meta", "clear", "mode", "clone", "close", "xtypedef", "name", "newl", "next", "nind", "encodeBytes", "addString", "forLoop", "overloads", "get_responseData", "writeBody", "writeByte", "setBlocking", "hasMethod", "path", "peer", "pmax", "pmin", "port", "prev", "push", "parseExpr", "keyValueIterator", "position", "origin", "initOps", "rdev", "read", "root", "matchedPos", "current", "__shiftStack", "mergeFields", "parseLambda", "assign", "execute", "seek", "size", "setInt32", "setInt64", "sock", "sort", "stop", "quicksort", "tabs", "tell", "type", "ctime", "readFullBytes", "waitForRead", "getUTCDay", "vals", "vars", "writeInt8", "preprocesorValues", "getMapValue", "wait", "mergeAbstracts", "values", "write", "waitLock", "spliceVoid", "allowReturn", "allowAsync", "isBlock", "writeNode", "parsePath", "writeBytes", "idents", "writeInput", "writeInt16", "writeInt24", "writeInt32", "cachedKey", "readFloat", "onBytes", "minutes", "isCompletion", "parseType", "LogFolder", "nodeValue", "parsePreproCond", "eventHandler", "parseRec", "__ownStack", "depth", "typeEq", "makeIterator", "getUTCMonth", "UUIDValue", "chunk_size", "get_previous", "lookupFunctions", "release", "setMapValue", "objString", "locals", "posInfos", "seconds", "onCompletion", "set_Code", "xenum", "concatNative", "noShutdown", "nBuckets", "getShort", "set_LogFolder", "className", "set_nodeValue", "setHeader", "resetVariables", "nextEventAt", "mimeType", "sortFields", "quote", "resolveEnum", "decodeString", "offset", "getField", "xmeta", "__unsafe_get", "__unsafe_set", "indexOf", "whileLoop", "addXmlType", "lookup", "fileName", "xpath", "getFloat", "headers", "getGlobals", "xroot", "fileTransfert", "onData", "retNull", "interfaces", "xtype", "onStatus", "toDynamic", "mkPath", "isNULL", "regex", "setGlobals", "resolve", "mergeDoc", "parseParams", "responseAsString", "readByte", "right", "isString", "readChar", "isSync", "t_string", "canSeek", "restore", "restoreVars", "addDouble", "shutdown", "oldTokenMax", "oldTokenMin", "getDefault", "ensureToken", "getMonth", "setContext", "xoverloads", "buildSync", "unwrap", "readMessage", "setParameter", "binops", "customParams", "params", "parent", "nextChar", "get_CurrentDeployEnvironment", "readInt8", "xerror", "parseMetaArgs", "identChars", "customRequest", "addEvent", "setVar", "readLine", "listen", "responseBytes", "children", "doParse", "get_canSeek", "_height", "set_CurrentDeployEnvironment", "bitAND", "bitXOR", "others", "process", "doDecodeString", "initParser", "__get", "__set", "parseExprList", "secureRandom", "nodeName", "error", "doEncodeInt", "__hx_deleteField", "parseExprNext", "currentFunType", "serialize", "ipAddress", "lineNumber", "rethrow", "cnxTimeout", "nodeType", "postBytes", "byteLength", "isEMPTY", "filename", "getUTCHours", "readUntil", "promise", "modulus", "upperBound", "unshift", "setUInt16", "getUTCFullYear", "strings", "doDecode", "linkLoop", "oneTimeEventsIdx", "follow", "skipTokens", "_keys", "unserialize", "preprocStack", "parseTypeNext", "exprToString", "doEncodeConst", "addFloat", "ensureElementType", "shash", "shift", "functionArgumentName", "matchedLeft", "fcall", "getFields", "addByte", "addChar", "removeMinBinding", "slice", "unserializeEnum", "complete", "currentBreak"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)))) );
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (( _g_idx < ( _g_arr as global::System.Array ).Length )) {
						_g_idx += ((uint) (1) );
						int i = _g_arr[((int) (((uint) (( _g_idx - 1 )) )) )];
						if (( global::haxe.lang.FieldLookup.findHash(i, cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( (( ci < clen )) ? (( ni < nlen )) : (false) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = ((string) (cfields[ci]) );
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = ((string) (nfields[ni]) );
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ( (( max - min )) / 2 ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return ((string) (global::haxe.lang.FieldLookup.fields[mid]) );
					}
					
				}
				
				throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)))) );
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (( s == null )) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						string field = ((string) (fld[mid]) );
						if (( field != s )) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.fieldIds = global::haxe.lang.FieldLookup.insertInt(global::haxe.lang.FieldLookup.fieldIds, global::haxe.lang.FieldLookup.length, min, key);
					global::haxe.lang.FieldLookup.fields = global::haxe.lang.FieldLookup.insertString(global::haxe.lang.FieldLookup.fields, global::haxe.lang.FieldLookup.length, min, s);
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ( (( max + min )) / 2 );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void removeInt(int[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = 0;
			}
		}
		
		
		public static void removeFloat(double[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = ((double) (0) );
			}
		}
		
		
		public static void removeDynamic(object[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = null;
			}
		}
		
		
		public static int[] insertInt(int[] a, int length, int pos, int x) {
			unchecked {
				int[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						int[] newarr = new int[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						int[] newarr1 = new int[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					int[] newarr2 = new int[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static double[] insertFloat(double[] a, int length, int pos, double x) {
			unchecked {
				double[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						double[] newarr = new double[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						double[] newarr1 = new double[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					double[] newarr2 = new double[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static object[] insertDynamic(object[] a, int length, int pos, object x) {
			unchecked {
				object[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						object[] newarr = new object[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						object[] newarr1 = new object[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					object[] newarr2 = new object[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = ((object) (x) );
				return a1;
			}
		}
		
		
		public static string[] insertString(string[] a, int length, int pos, string x) {
			unchecked {
				string[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						string[] newarr = new string[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						string[] newarr1 = new string[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					string[] newarr2 = new string[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static global::haxe.lang.FieldHashConflict getHashConflict(global::haxe.lang.FieldHashConflict head, int hash, string name) {
			while (( head != null )) {
				if (( ( head.hash == hash ) && ( head.name == name ) )) {
					return head;
				}
				
				head = head.next;
			}
			
			return null;
		}
		
		
		public static void setHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name, object @value) {
			global::haxe.lang.FieldHashConflict node = head;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					node.@value = @value;
					return;
				}
				
				node = ((global::haxe.lang.FieldHashConflict) (node.next) );
			}
			
			head = ((global::haxe.lang.FieldHashConflict) (new global::haxe.lang.FieldHashConflict(hash, name, @value, ((global::haxe.lang.FieldHashConflict) (head) ))) );
		}
		
		
		public static bool deleteHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name) {
			if (( head == null )) {
				return false;
			}
			
			if (( ( head.hash == hash ) && ( head.name == name ) )) {
				head = ((global::haxe.lang.FieldHashConflict) (head.next) );
				return true;
			}
			
			global::haxe.lang.FieldHashConflict prev = head;
			global::haxe.lang.FieldHashConflict node = head.next;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					prev.next = node.next;
					return true;
				}
				
				node = node.next;
			}
			
			return false;
		}
		
		
		public static void addHashConflictNames(global::haxe.lang.FieldHashConflict head, global::Array<string> arr) {
			while (( head != null )) {
				arr.push(head.name);
				head = head.next;
			}
			
		}
		
		
	}
}


