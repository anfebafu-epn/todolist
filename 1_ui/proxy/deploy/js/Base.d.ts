/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

/**
 * ...
 * @author Smartwork
 */
export class nMorph_core_proxy_tools_Initializer {
	constructor();
	static Init(): string;
}

/**
 * Método que permite invocar a los métodos de lógica
 * @author Smartwork
 */
export class nMorph_core_proxy_tools_Packager {
	constructor();
	static Serialize(obj: any): string;
	static Unserialize(SerializedStr: string): any;
}

export class haxe__Int64____Int64 {
	constructor(high: number, low: number);
	high: number;
	low: number;
	/**
	 * We also define toString here to ensure we always get a pretty string
	 * when tracing or calling `Std.string`. This tends not to happen when
	 * `toString` is only in the abstract.
	 */
	toString(): string;
}

export class haxe_io_Bytes {
	protected constructor(data: ArrayBuffer);
	readonly length: number;
	/**
	 * Returns the byte at index `pos`.
	 */
	get(pos: number): number;
	/**
	 * Stores the given byte `v` at the given position `pos`.
	 */
	set(pos: number, v: number): void;
	/**
	 * Copies `len` bytes from `src` into this instance.
	 * @param pos Zero-based location in `this` instance at which to start writing
	 * bytes.
	 * @param src Source `Bytes` instance from which to copy bytes.
	 * @param srcpos Zero-based location at `src` from which bytes will be copied.
	 * @param len Number of bytes to be copied.
	 */
	blit(pos: number, src: haxe_io_Bytes, srcpos: number, len: number): void;
	/**
	 * Sets `len` consecutive bytes starting from index `pos` of `this` instance
	 * to `value`.
	 */
	fill(pos: number, len: number, value: number): void;
	/**
	 * Returns a new `Bytes` instance that contains a copy of `len` bytes of
	 * `this` instance, starting at index `pos`.
	 */
	sub(pos: number, len: number): haxe_io_Bytes;
	/**
	 * Returns `0` if the bytes of `this` instance and the bytes of `other` are
	 * identical.
	 * Returns a negative value if the `length` of `this` instance is less than
	 * the `length` of `other`, or a positive value if the `length` of `this`
	 * instance is greater than the `length` of `other`.
	 * In case of equal `length`s, returns a negative value if the first different
	 * value in `other` is greater than the corresponding value in `this`
	 * instance; otherwise returns a positive value.
	 */
	compare(other: haxe_io_Bytes): number;
	/**
	 * Returns the IEEE double-precision value at the given position `pos` (in
	 * little-endian encoding). Result is unspecified if `pos` is outside the
	 * bounds.
	 */
	getDouble(pos: number): number;
	/**
	 * Returns the IEEE single-precision value at the given position `pos` (in
	 * little-endian encoding). Result is unspecified if `pos` is outside the
	 * bounds.
	 */
	getFloat(pos: number): number;
	/**
	 * Stores the given IEEE double-precision value `v` at the given position
	 * `pos` in little-endian encoding. Result is unspecified if writing outside
	 * of bounds.
	 */
	setDouble(pos: number, v: number): void;
	/**
	 * Stores the given IEEE single-precision value `v` at the given position
	 * `pos` in little-endian encoding. Result is unspecified if writing outside
	 * of bounds.
	 */
	setFloat(pos: number, v: number): void;
	/**
	 * Returns the 16-bit unsigned integer at the given position `pos` (in
	 * little-endian encoding).
	 */
	getUInt16(pos: number): number;
	/**
	 * Stores the given 16-bit unsigned integer `v` at the given position `pos`
	 * (in little-endian encoding).
	 */
	setUInt16(pos: number, v: number): void;
	/**
	 * Returns the 32-bit integer at the given position `pos` (in little-endian
	 * encoding).
	 */
	getInt32(pos: number): number;
	/**
	 * Stores the given 32-bit integer `v` at the given position `pos` (in
	 * little-endian encoding).
	 */
	setInt32(pos: number, v: number): void;
	/**
	 * Returns the 64-bit integer at the given position `pos` (in little-endian
	 * encoding).
	 */
	getInt64(pos: number): haxe__Int64____Int64;
	/**
	 * Stores the given 64-bit integer `v` at the given position `pos` (in
	 * little-endian encoding).
	 */
	setInt64(pos: number, v: haxe__Int64____Int64): void;
	/**
	 * Returns the `len`-bytes long string stored at the given position `pos`,
	 * interpreted with the given `encoding` (UTF-8 by default).
	 */
	getString(pos: number, len: number, encoding?: any): string;
	readString(pos: number, len: number): string;
	/**
	 * Returns a `String` representation of the bytes interpreted as UTF-8.
	 */
	toString(): string;
	/**
	 * Returns a hexadecimal `String` representation of the bytes of `this`
	 * instance.
	 */
	toHex(): string;
	/**
	 * Returns the bytes of `this` instance as `BytesData`.
	 */
	getData(): ArrayBuffer;
	/**
	 * Returns a new `Bytes` instance with the given `length`. The values of the
	 * bytes are not initialized and may not be zero.
	 */
	static alloc(length: number): haxe_io_Bytes;
	/**
	 * Returns the `Bytes` representation of the given `String`, using the
	 * specified encoding (UTF-8 by default).
	 */
	static ofString(s: string, encoding?: any): haxe_io_Bytes;
	/**
	 * Returns the `Bytes` representation of the given `BytesData`.
	 */
	static ofData(b: ArrayBuffer): haxe_io_Bytes;
	/**
	 * Converts the given hexadecimal `String` to `Bytes`. `s` must be a string of
	 * even length consisting only of hexadecimal digits. For example:
	 * `"0FDA14058916052309"`.
	 */
	static ofHex(s: string): haxe_io_Bytes;
	/**
	 * Reads the `pos`-th byte of the given `b` bytes, in the most efficient way
	 * possible. Behavior when reading outside of the available data is
	 * unspecified.
	 */
	static fastGet(b: ArrayBuffer, pos: number): number;
}

export class nMorph_framework_common_datatypes_UUID {
	/**
	 * Inicializa un UUID con valor 0
	 */
	constructor();
	/**
	 * Almacena el valor string determinado internamente
	 * @param	Valor en string
	 * @return
	 */
	setValue(UUIDString: string): nMorph_framework_common_datatypes_UUID;
	assign(b: string): nMorph_framework_common_datatypes_UUID;
	equals(b: nMorph_framework_common_datatypes_UUID): boolean;
	diff(b: nMorph_framework_common_datatypes_UUID): boolean;
	/**
	 * Obtiene el UUID almacenado en String
	 * @param	UUID
	 * @return string interno almacenado
	 */
	getValue(): string;
	/**
	 * Obtiene el UUID almacenado en String
	 * @param	UUID
	 * @return string interno almacenado
	 */
	toString(): string;
	/**
	 * Obtiene la representación en formato short
	 * @return
	 */
	getShort(): string;
	/**
	 * Obtiene la representación en formato Nano
	 * @return
	 */
	getNano(): string;
	/**
	 * Devuelve la representación del UUID en Bytes
	 * @return
	 */
	getBytes(): haxe_io_Bytes;
	/**
	 * Establece el valor desde un tipo de dato Bytes
	 * @param	UUIDBytes
	 */
	setValuefromBytes(UUIDBytes: haxe_io_Bytes): nMorph_framework_common_datatypes_UUID;
	/**
	 * Valida si el valor es EMPTY
	 * @return
	 */
	isEMPTY(): boolean;
	/**
	 * Valida si el valor es NULL
	 * @return
	 */
	isNULL(): boolean;
	/**
	 * Crea un nuevo UUID vacío
	 */
	static empty(): nMorph_framework_common_datatypes_UUID;
	/**
	 * Crea un UUID desde Bytes
	 * @param	UUIDBytes
	 */
	static fromBytes(UUIDBytes: haxe_io_Bytes): nMorph_framework_common_datatypes_UUID;
	/**
	 * Genera un valor UUID de forma aleatoria utilizando algoritmo v4
	 * @return
	 */
	static newUUID(): nMorph_framework_common_datatypes_UUID;
	/**
	 * Genera un UUID desde un String
	 * @param	UUID en string
	 * @return  UUID
	 */
	static fromString(UUIDString: string): nMorph_framework_common_datatypes_UUID;
}

export class nMorph_framework_svc_msg_RequestMessage {
	constructor();
	set_RequestSeq(value: number): number;
	get_RequestSeq(): number;
	get_SessionID(): string;
	set_SessionID(value: string): string;
	get_Calls(): nMorph_framework_svc_transport_MethodCall[];
	set_Calls(value: nMorph_framework_svc_transport_MethodCall[]): nMorph_framework_svc_transport_MethodCall[];
}

export class nMorph_framework_svc_msg_ResponseMessage {
	constructor();
	set_Results(value: nMorph_framework_svc_transport_MethodResult[]): nMorph_framework_svc_transport_MethodResult[];
	get_Results(): nMorph_framework_svc_transport_MethodResult[];
	set_RequestSeq(value: number): number;
	get_RequestSeq(): number;
	set_Message(value: string): string;
	get_Message(): string;
	get_AttentionCode(): string;
	set_AttentionCode(value: string): string;
}

export class nMorph_framework_svc_transport_MethodCall {
	constructor();
	set_LogicModule(value: string): string;
	get_LogicModule(): string;
	set_LogicClass(value: string): string;
	get_LogicClass(): string;
	set_LogicMethod(value: string): string;
	get_LogicMethod(): string;
	set_LogicParams(value: any[]): any[];
	get_LogicParams(): any[];
	get_Name(): string;
	set_Name(value: string): string;
}

export class nMorph_framework_svc_transport_MethodResult {
	constructor();
	get_ReturnObject(): any;
	set_ReturnObject(value: any): any;
	get_Name(): string;
	set_Name(value: string): string;
}